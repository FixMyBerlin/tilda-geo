import { $ } from 'bun'
import chalk from 'chalk'
import { join } from 'path'
import { OSM_DOWNLOAD_DIR } from '../constants/directories.const'
import { params } from '../utils/parameters'

//Geofabrik OAuth base URL, https://github.com/geofabrik/sendfile_osm_oauth_protector/blob/master/doc/client.md
const GEOFABRIK_OAUTH_BASE_URL = 'https://osm-internal.download.geofabrik.de'

export const COOKIE_FILE = join(OSM_DOWNLOAD_DIR, 'geofabrik_oauth_cookie.txt')
const OAUTH_SETTINGS_FILE = join(OSM_DOWNLOAD_DIR, 'oauth_settings.json')

/**
 * Ensure we have a valid OAuth cookie, getting a new one if needed
 * Returns cookie information if OAuth is ready, null if OAuth is disabled or failed
 * If OAuth fails, falls back to public download by modifying params
 */
export async function ensureOAuthReady() {
  // If no credentials, fall back immediately
  if (!(params.osmUsername && params.osmPassword)) {
    console.log('Geofabrik OAuth: ⏩ OAuth disabled (no credentials); using public data')
    fallbackToPublicDownload()
    return null
  }

  try {
    // Always create a fresh cookie and use it directly
    await createOAuthCookie()
    // Retrieve cookie written by the Python client
    const { httpCookie } = await getCookieFile()
    if (httpCookie) {
      console.log('Geofabrik OAuth: OAuth is ready with fresh cookie')
      return {
        isValid: true,
        httpCookie,
      } as const
    }
  } catch (error) {
    console.error('[ERROR] Geofabrik OAuth: Failed to create or retrieve cookie:', error)
  }

  console.log(
    chalk.red('Geofabrik OAuth: OAuth initialization failed; falling back to public data'),
  )
  fallbackToPublicDownload()
  return null
}

/**
 * Check if we have a valid OAuth cookie and return cookie information
 * Returns { isValid: boolean, httpCookie?: string }
 */
// Note: Cookie reuse and validation helpers removed. We always create and use a fresh cookie.

/**
 * Create and store OAuth cookie using the Geofabrik client
 * This will authenticate with OSM and get a cookie for authenticated downloads
 */
async function createOAuthCookie() {
  if (params.osmUsername && params.osmPassword) {
    console.log('Geofabrik OAuth: Create new cookie…')
  } else {
    return
  }

  try {
    // Create settings file to pass to python via `OAUTH_SETTINGS_FILE`
    await createOAuthSettings()

    // Run the OAuth client to get the cookie
    // The Python script writes a Netscape-format cookie file to `COOKIE_FILE`.
    // We retrieve it immediately afterwards using `getCookieFile()`.
    const result =
      await $`python3 /usr/local/bin/oauth_cookie_client.py -o ${COOKIE_FILE} -s ${OAUTH_SETTINGS_FILE} -f netscape`.quiet()

    if (result.exitCode === 0) {
      console.log('Geofabrik OAuth: New Cookie saved')
    } else {
      console.error(
        '[ERROR] Geofabrik OAuth: OAuth authentication failed with exit code',
        result.exitCode,
        result,
      )
      throw new Error(`OAuth authentication failed with exit code ${result.exitCode}`)
    }
  } catch (error) {
    console.error('[ERROR] Geofabrik OAuth: createOAuthCookie failed', error)
    throw error
  }
}

/**
 * Create OAuth settings file for the Geofabrik client
 */
async function createOAuthSettings() {
  if (!params.osmUsername || !params.osmPassword) {
    throw new Error('OAuth credentials are not configured.')
  }

  const settings = {
    user: params.osmUsername,
    password: params.osmPassword,
    osm_host: 'https://www.openstreetmap.org',
    consumer_url: `${GEOFABRIK_OAUTH_BASE_URL}/get_cookie`,
  }

  await Bun.write(OAUTH_SETTINGS_FILE, JSON.stringify(settings, null, 2))
}

/**
 * Parse Netscape cookie format and extract the cookie value for HTTP requests
 */
function parseNetscapeCookie(cookieContent: string) {
  const lines = cookieContent.split('\n')
  for (const line of lines) {
    if (line.startsWith('#') || line.trim() === '') continue

    const parts = line.split('\t')
    if (parts.length >= 7) {
      const cookieName = parts[5]
      const cookieValue = parts[6]
      return `${cookieName}=${cookieValue}`
    }
  }
  return null
}

/**
 * Switch to public Geofabrik downloads and disable OAuth credentials
 */
export function fallbackToPublicDownload() {
  params.pbfDownloadUrl = params.pbfDownloadUrl
    .replaceAll('osm-internal.download.geofabrik.de', 'download.geofabrik.de')
    .replaceAll('-internal', '')
  params.osmUsername = undefined
  params.osmPassword = undefined
}

/**
 * Read the cookie file generated by the Python client, parse to HTTP header value, then delete the file.
 * The Python client stores the OAuth cookie in Netscape format; we retrieve it here for immediate use.
 */
async function getCookieFile() {
  const cookieFile = Bun.file(COOKIE_FILE)
  if (await cookieFile.exists()) {
    const cookieContent = await cookieFile.text()
    const httpCookie = cookieContent ? parseNetscapeCookie(cookieContent) : null
    return { cookieContent, httpCookie }
  }
  return { cookieContent: null, httpCookie: null }
}

/**
 * Get headers for HTTP requests, including OAuth cookie if enabled
 */
export function getAuthHeaders(httpCookie: string | undefined) {
  const headers: HeadersInit = {}

  if (httpCookie) {
    headers['Cookie'] = httpCookie
  }

  return headers
}

/**
 * Validate that the OAuth cookie works by making a test request
 */
export async function validateOAuthCookie(httpCookie: string, testUrl: string): Promise<boolean> {
  try {
    const response = await fetch(testUrl, {
      method: 'HEAD',
      headers: getAuthHeaders(httpCookie),
    })
    return response.ok
  } catch (error) {
    console.error('[ERROR] Geofabrik OAuth: Cookie validation failed:', error)
    return false
  }
}
